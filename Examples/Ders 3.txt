/*----------------------------------------
eğer auto&& ile bir değişken bildirilirse
 bu değişkene
 a-)sabit ifadesiyle ilk değer verilirse
 bu durumda bu değişkenin türü int&& olur
 b-)değişken ifadesiyle ilk değer verilirse
 bu durumda bu değişkenin türü int& olur
 (autoya karşılık int& ancak reference collapsing
 kuralı devreye girer ve bu değişkenin
 türü int& olur.)
-----------------------------------------*/
#include <vector>
#include <list>

int main()
{
    int y = 10;
    int&& r1 = 25;
    int& r2 = y;
    auto&& x = y;
    return 0;
}

//-----------------------------------------

#include <iostream>

int main() {
    char ch='A';
    auto x1=ch;//x1'in türü char
    auto x2=+ch;//x2'nin türü int
    std::cout << x2;
    printf("%d",x2);
    return 0;
}

/*--------------------------------------------------------
Aşağıdaki örnekte x'in türü int*'dır.
-------------------------------------------------------*/
#include <iostream>

void displayArray(const int arr[],int size)
{
    for(int i = 0;i < size;++i)
    {
        std::cout << *(arr + i) << ' ';
    }
    std::cout << '\n';
}

int main() {
    int arr[]{1,2,3};
    auto x=arr;
}

/*--------------------------------------------------------
Aşağıdaki örnekte str'nin türü const char*'dır.
Array decay kuralından dolayı C++ dilinde stringlerin
türü const char[] dir. bu atama sırasında da array decay gerçekleşir.
Buna göre tür çıkarımı const char* olarak yapılır.
-------------------------------------------------------*/
int main()
{
    auto str="berke";
    char* s1 = "elif";//warning!!
}
/*--------------------------------------------------------
Aşağıdaki örnekte x'in türü int(*)[20]'dir. Bunun nedeni
m'nin atanırken ilk elemanının adresi olarak ele alındığı
için 20 elemanlı int* türünden bir pointer dizisi elde edilir.
-------------------------------------------------------*/
int main() {
    int m[10][20];
    auto x=m;
}
/*----------------------------------------------------
Anahtar Notlar: Referansların ve pointerın bir diğer farkı
ise pointerlarda pointer aritmetiği varken bunun
referanslarda söz konusu olmamasıdır.
---------------------------------------------------*/

//-------------------------------------------------------
/*--------------------------------------------------------
Aşağıdaki örnekte auto'nun karşılığı çıkarım yapılan tür int[10]
Bu durumda x değişkeni int(&x)[10] türündendir.
-------------------------------------------------------*/
int main(){
    int a[10]{};
    auto &x = a;
    auto y = a;
}
/*--------------------------------------------------------
Aşağıdaki örnekte autoya karşılık gelen ifade const char[6]
r'nin türüyse const char& [6] yani yorum satırında gösterildiği
gibi yazmak yerine auto kullanmak çok daha mantıklı bir
yaklaşım olacaktır.
Anahtar Notlar: const char [] türünden yazıların hepsinin
sonunda '\0' karakter bulunur ancak C++ bir tür eş ismi olan
string containerı için bu geçerli değildir.
-------------------------------------------------------*/
int main(){

    auto& r="berke";
    auto r1 = "berke";
    //const char (&r) [6]="berke";
}

/*--------------------------------------------------------
Aşağıdaki örnekte const ile auto anahtar sözcüğü
 birlikte kullanılmıştır. Bu durumda y'nin türü
 const int olucaktır.
-------------------------------------------------------*/
int main(){

    int x=34;
    const auto y=x;
}
/*--------------------------------------------------------
Aşağıdaki örnekte p1 consttur ancak *p1 const değildir
 bu sebeple p1'in başka bir adresi syntax hatasına neden
 olur ancak *p1 değiştirilmesi legaldir. p1 ve p2 için
 ikisinin de const anahtar sözcüğü * deklatöründen
 önce olduğu için *p1 ve *p2 değerleri const olmuştur.
 bu sebeple değiştirme girişim syntax hatasına sebep olur.
 Ancak p1 ve p2'nin başka adresleri göstermesi legaldir.
-------------------------------------------------------*/
int main(){
    int x = 25;
    int y = 56;
    int z = 98;
    int* const p1 = &x;
    p1 = &y;
    *p1 = 67;
    const int* p2 = &y;
    p2 = &z;
    *p2 = 78;
    int const* p3 = &z;
    p3 = &x;
}

/*--------------------------------------------------------
Aşağıdaki örnekte y'nin int* const(high veya top level const) iken z'nin türü
 const int*(low level const) olacaktır. Yani birinde y değiştiremezken
 diğerinde *z değiştirelemez olacaktır.
-------------------------------------------------------*/
int main()
{
    int x=34;
    const auto y=&x;
    const auto*z=&x;
}

/*--------------------------------------
 char türden bir dizinin elemanlarının değiştirilmesi
 herhangi problemli bir duruma sebep olmaz ancak
 char diziyi gösteren bir pointer değişken üzerinden
 bir string literalinin değiştirilme girişimi
 undefined behavioura sebep olur.
 ----------------------------------------*/
#include <stdio.h>


int main()
{
    const char* s1 = "ankara";
    char s2[] = "ankara";
    *s1 = 'b'; //ub
    s2[0] = 'b'; //sorun yok
    printf("%s\n",s1);
    printf("%s\n",s2);
}
/*--------------------------------------------------------
C++ 4 farklı nesne ömrü vardır bunlar:
 1-)otomatik ömürlü nesneler(Automatic lifetime objects):
 yerel değişkenler, fonksiyonların parametre değişkenleri
 yerel sınıf nesneleri otomatik ömürlü
 2-)static ömürlü nesneler(static lifetime objects):
 global değişkenler, static yerel değişkenler veya static
 global değişkenler.
 3-)Dinamik ömürlü nesneler(Dynamic lifetime objects):
 Sınıf nesneleri new operatörüyle birlikte kullanımıyla
 bir dinamik ömürlü nesne yaratımı yapılabilir ancak
 bu nesnelerin delete operatörüyle geri verilmesi gerekir
 aksi durumda resource leak oluşur. malloc calloc gibi
 standart kütüphane fonksiyonlarıyla dinamik ömürlü diziler
 oluşturulabilir ancak bu bellek free fonksiyonuyla mutlaka
 geri verilmesi gerekir aksi durum memory leak oluşur.
 4-)Thread local nesneler(Thread local objects):
 Bu kısmı concurrency konusuna geçtiğimizde inceleyecez.
-------------------------------------------------------*/
#include <iostream>
#include <cstdlib>


class Myclass{
public:
    Myclass()
    {
        std::cout << "Myclass default constructor" << '\n';
    }
};

int main()
{
    int size;
    std::cout << "Enter size?" << '\n';
    std::cin >> size;
    int* arr = (int*)std::malloc(size * sizeof(int));
    Myclass m;
    delete m;
    free(arr);
}
//--------------------------------------------------------------

#include <iostream>

constexpr int func(const int x,const int y){

    return x*x+y*y;
}

constexpr bool isPrime(const int val)
{
    if(val <= 1)
        return false;
    if(val % 2 == 0)
        return val == 2;
    if(val % 3 == 0)
        return val == 3;
    if(val % 5 == 0)
        return val == 5;
    if(val % 7 == 0)
        return val == 7;
    if(val % 11 == 0)
        return val == 11;
    for(int i = 13;i * i < val;i+= 2){
        if(val % i == 0)
            return false;
    }
    return true;
}

int main(){
    std::cout << func(10,20);
    std::cout << std::boolalpha << isPrime(11)<<'\n';
}

/*--------------------------------------------------------
C++'ta iki tip polimorfzim vardır.,
 1-)Compile-time polimorfzim(Function overloading)
 2-)Runtime polimorfzim(Function overriding)
-------------------------------------------------------*/